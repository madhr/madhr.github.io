---
layout: post
title:  "Markov chain melody generator"
abstract: "Using Markov chain to generate music sequences."
date:   2020-03-07 19:42:34 +0100
categories: python midi markov-chain generator
thumbnail: markov-thumbnail.jpg
author: Magda Hrebecka
---

Can we just automate music making?

I'm as lazy a musician as a developer, so I wanted to force the computer to make songs for me (again, as I already tried forcing it <a href="{{site.baseurl}}/python/midi/weather/generator/2020/02/13/python-weather-midi-generator.html">here</a>). As usual, it required a little bit of research on 'math stuff' to find something that would suit my needs. And I think I found it.

<h4>What is Markov chain?</h4>

Markov chain is a stochastic model used to describe a sequence of possible events, where probability of each event is depentant solely on the previous event. It can be used for simplified weather forecasting, stock market preditions etc. In music it's not really true that each note depends solely on previous one, as we have music keys and other rules. For this experiment I decided to go simple and not dig too deep into music theory.

<h4>Approach</h4>

I used midi files found at <a href="https://freemidi.org">https://freemidi.org</a>.

First, we have to extract chords from midi track, and group them into list of chords. Numbers in the inner list represent midi notes.

{% highlight python %}
chords_list = [
	[55, 60, 64, 69], [55, 60, 64, 69], [45], [45], [55, 60, 64, 69], 
	[55, 60, 64, 69], [54, 60, 64, 71], [54, 60, 64, 71], [54, 60, 64, 71], 
	[54, 60, 64, 71], [54, 60, 64, 71], [54, 60, 64, 71], [54, 59, 62, 69], 
	[54, 59, 62, 69], [54, 57, 59, 62], [54, 57, 59, 62], [43], [43], 
	[54, 57, 59, 62], [54, 57, 59, 62], [52, 55, 59, 62], [52, 55, 59, 62], 
	[52, 55, 59, 62], [52, 55, 59, 62], [52, 59, 62, 67], [52, 59, 62, 67]
]
{% endhighlight %}

For each chord in the list, we need to store ay possible next chord. Let's use a dictionary for that:

{% highlight python %}
dictionary = {
	(55, 60, 64, 69): 
		[(55, 60, 64, 69), (45,), (55, 60, 64, 69), (54, 60, 64, 71)], 
	(45,): 
		[(45,), (55, 60, 64, 69)], 
	(54, 60, 64, 71): 
		[(54, 60, 64, 71), (54, 60, 64, 71), (54, 60, 64, 71), (54, 60, 64, 71), (54, 60, 64, 71), (54, 59, 62, 69)], 
	(54, 59, 62, 69): 
		[(54, 59, 62, 69), (54, 57, 59, 62)], 
	(54, 57, 59, 62): 
		[(54, 57, 59, 62), (43,), (54, 57, 59, 62), (52, 55, 59, 62)], 
	(43,): [(43,), (54, 57, 59, 62)], 
	(52, 55, 59, 62): 
		[(52, 55, 59, 62), (52, 55, 59, 62), (52, 55, 59, 62), (52, 59, 62, 67)], 
	(52, 59, 62, 67): 
		[(52, 59, 62, 67)]
}
{% endhighlight %}

Now we need to calculate the probability of the next values. Let's take key `(55, 60, 64, 69)` as an example.

{% highlight plaintext %}
(55, 60, 64, 69) - 2
(45,) - 1
(54, 60, 64, 71) - 1
{% endhighlight %}

and after normalizing it:

{% highlight plaintext %}
(55, 60, 64, 69) - 0.5
(45,) - 0.25
(54, 60, 64, 71) - 0.25
{% endhighlight %}

If we drew a graph for it, it would look like that:

<img src="{{site.baseurl}}/assets/img/markov-graph.jpg" style="width:50%"/>

Note that starting from chord `(55, 60, 64, 69)` we have 50% chance to repeat it.

We're going to use a <a href="https://docs.python.org/3/library/random.html#random.choices">python function</a> for getting random element from non-empty sequence and its weights:
`random.choices(population, weights=None, *, cum_weights=None, k=1)`

{% highlight python %}
population = [(55, 60, 64, 69), (45,), (54, 60, 64, 71)]
weights = [0.5, 0.25, 0.25]
{% endhighlight %}

The randomly picked chord from population will be our next chord in the sequence. Now we can just repeat the process n times to generate a longer sequence.

Whole algorithm:
{% highlight python %}
def generate_sequence(self, input_dict: dict, current: tuple, sequence: list, count: int, max: int) -> list:
	if max == count:
		return sequence
	candidates = input_dict[current]

	chord_occurences_dict = dict()
	probabilities_list = []
	for candidate in candidates:
		chord_occurences_dict[candidate] = candidates.count(candidate)

	occurences_sum = sum(chord_occurences_dict.values())

	for key in chord_occurences_dict:
		normalized_prob = chord_occurences_dict[key] * (1 / occurences_sum)
		probabilities_list.append(normalized_prob)

	options_list = list(chord_occurences_dict.keys())

	chosen = random.choices(options_list, probabilities_list)[0]
	sequence.append(chosen)
	count = count + 1
	return self.generate_sequence(input_dict, chosen, sequence, count, max)
{% endhighlight %}

The final sequence generated by the algorithm looks like that:

{% highlight python %}
sequence = [
	(55, 60, 64, 69), (45,), (55, 60, 64, 69), (55, 60, 64, 69), (54, 60, 64, 71), 
	(54, 60, 64, 71), (54, 60, 64, 71), (54, 59, 62, 69), (54, 57, 59, 62), (43,)
]
{% endhighlight %}


<h4>Results</h4>

I've tried running the script on many midi files and quickly realized that majority of free midi files are a mess. Some have all lines (bass, chords, vocal) put together into one track - the generated sequence would then sound like a cacophony. Some of them have all notes in separate tracks (each track being mono), therefore the sequence would sound pretty random.
Below are the sequences generated out of two jazz standards. I think they sound good, maybe I could even use them in a free jazz jam?

<iframe width="100%" height="150" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/771949948&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true"></iframe>

<iframe width="100%" height="150" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/771949945&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true"></iframe>

<h4>Summary</h4>

The approach works best with 'complex' jazz chords. I tried running it for pop songs and it sounds poor, mainly because it tends to get stuck on one chord for ages. Markov chains are not good for generating monophonic melodies either - it just sounds too random.

Long live jazz!

See full code <a href="https://github.com/madhr/markov-chain-melody-generator">here</a>.